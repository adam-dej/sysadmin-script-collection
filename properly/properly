#!/bin/sh

### READ CONFIG ################################################################

CONFIG='/usr/local/etc/defaults/properly.conf'
# pull in config
. $CONFIG
for f in $local_config_files; do
	. $f
done

### ARGUMENTS PARSING ##########################################################

usage() {
	echo "Usage: $0 [-t title] [-s slug] command [arguments...]"
	exit 1
}

parse_args() {
	while getopts "s:t:" opt; do
		case ${opt} in
			t)
				title=${OPTARG}
				;;
			s)
				slug=${OPTARG}
				;;
		esac
	done
	shift $(( ${OPTIND} - 1 )) # TODO: odprasit
	command="$@"
	[ -z "$command" ] && usage
	[ -z "$title" ] && title="$(to_title $command)"
	[ -z "$slug" ] && slug="$(to_slug $title)"
}

to_title() {
	date "+$* %Y/%m/%d"
}

to_slug() {
	echo $@ | tr ' /\t' '---'
}

### HELPER FUNCTIONS ###########################################################

STDOUT_PREFIX=' * '
STDOUT_COMPLAIN_PREFIX='!!!'

complain() {
	echo "${STDOUT_COMPLAIN_PREFIX} $@"
	read -p "${STDOUT_COMPLAIN_PREFIX}     Type \"yes\" to continue (on your own responsibility): " REPLY
	if [ x"$REPLY" != x'yes' ]; then
		msg 'Aborted.'
		exit 47
	fi
}

msg() {
	echo "${STDOUT_PREFIX}$@"
}

ask() {
	read -p "${STDOUT_PREFIX}$@ [Y/n] " REPLY
	[ x"$REPLY" = x -o x"$REPLY" = x"Y" -o x"$REPLY" = x"y" ]
}

execute() {
	$command || msg "(exit status: $?)"
}

### CHECKS AND ACTIONS #########################################################

dirty_config_dirs() {
	dirty=""
	for dir in $etcundergit_dirs; do
		( cd $dir && [ -z "$(git status --porcelain)" ] ) || dirty="$dirty $dir"
	done
	echo $dirty
}

check_config_clean() {
	dirty_dirs="$(dirty_config_dirs)"
	for d in $dirty_dirs; do
		msg "$d is dirty"
	done
	[ -z "$dirty_dirs" ]
}

commit_config() {
	title="$1"
	slug="$2"
	for d in $(dirty_config_dirs); do
		(
			cd $d
			run_git add --all .
			# empty commit just prints a message
			run_git commit -m "$title [autocommit]" && run_git tag "$slug"
		)
	done
}

do_snapshot() {
	snapshot="${snapshot_subvol}@${1}"
	msg "creating snapshot: $snapshot"
	zfs snapshot -r "$snapshot"
}

log() {
	logfile="${techwiki_location}${techwiki_setup_log}"
	mv "${logfile}" "${logfile}.old"
	head -n 2 < "${logfile}.old" > "${logfile}.tmp"
	echo "" >> "${logfile}.tmp"
	echo "  * $(date +%Y-%m-%d) $1 <$2>" >> "${logfile}.tmp"
	echo "    * \`$3\`" >> "${logfile}.tmp"
	echo "" >> "${logfile}.tmp"
	tail -n +3 < "${logfile}.old" >> "${logfile}.tmp"
	mv "${logfile}.tmp" "${logfile}"
	rm "${logfile}.old"

}

### "PROPERLY" SEQUENCE ########################################################

parse_args "$@"

# Executing $command properly means:
msg '=== 0) check if config directories (such as /etc) are clean =============='
check_config_clean || complain 'Uncommitted config changes!'
msg '=== 1) snapshot =========================================================='
do_snapshot "pre-$slug" || complain "Cannot create snapshot (exit code $?)!"
msg '=== execute command ======================================================'
execute "$command"
msg '=== n-2) commit config changes ==========================================='
ask 'Autocommit config changes?' && commit_config "$title" "$slug"
msg '=== n-1) snapshot ========================================================'
do_snapshot "post-$slug" || msg "Couldn't create snapshot (exit code $?)!"
msg '=== n) log the change ===================================================='
log "$title" "$slug" "$command"
msg 'Done. Check setup log and commit it when you are done.'
